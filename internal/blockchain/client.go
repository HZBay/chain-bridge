// Code generated by "make swagger"; DO NOT EDIT.
package blockchain

import (
	"context"
	"crypto/ecdsa"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"

	cpop "github.com/HzBay/account-abstraction/cpop-abis"
)

// CPOPClient handles interaction with CPOP account abstraction contracts
type CPOPClient struct {
	client         *ethclient.Client
	chainID        *big.Int
	accountManager *cpop.AccountManager

	// Configuration
	config CPOPConfig
}

// CPOPConfig contains configuration for CPOP blockchain client
type CPOPConfig struct {
	RPCEndpoint           string
	AccountManagerAddress common.Address
	EntryPointAddress     common.Address
	GasPriceFactor        float64
	DefaultGasLimit       uint64
}

// DeploymentResult contains result of account deployment
type DeploymentResult struct {
	TxHash         string
	AccountAddress string
	GasUsed        uint64
	GasPrice       *big.Int
}

// CostEstimate contains gas cost estimation
type CostEstimate struct {
	GasLimit     uint64
	GasPrice     *big.Int
	TotalCostWei *big.Int
	TotalCostETH string
}

// NewCPOPClient creates a new CPOP blockchain client
func NewCPOPClient(config CPOPConfig) (*CPOPClient, error) {
	client, err := ethclient.Dial(config.RPCEndpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to blockchain: %w", err)
	}

	chainID, err := client.ChainID(context.Background())
	if err != nil {
		return nil, fmt.Errorf("failed to get chain ID: %w", err)
	}

	// Initialize AccountManager contract
	accountManager, err := cpop.NewAccountManager(config.AccountManagerAddress, client)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize AccountManager contract: %w", err)
	}

	return &CPOPClient{
		client:         client,
		chainID:        chainID,
		accountManager: accountManager,
		config:         config,
	}, nil
}

// CreateAccountAddress generates a deterministic account address using AccountManager contract
func (c *CPOPClient) CreateAccountAddress(ctx context.Context, ownerAddress string, salt *big.Int) (string, error) {
	// Convert string address to common.Address
	owner := common.HexToAddress(ownerAddress)

	// Get default master signer from the AccountManager contract
	masterSigner, err := c.accountManager.GetDefaultMasterSigner(&bind.CallOpts{Context: ctx})
	if err != nil {
		return "", fmt.Errorf("failed to get default master signer: %w", err)
	}

	// Call the AccountManager contract's getAccountAddress function
	accountAddress, err := c.accountManager.GetAccountAddress(&bind.CallOpts{Context: ctx}, owner, masterSigner)
	if err != nil {
		return "", fmt.Errorf("failed to get account address from AccountManager: %w", err)
	}

	return accountAddress.Hex(), nil
}

// CreateAccountAddressWithMasterSigner generates a deterministic account address with custom master signer
func (c *CPOPClient) CreateAccountAddressWithMasterSigner(ctx context.Context, ownerAddress string, masterSignerAddress string) (string, error) {
	// Convert string addresses to common.Address
	owner := common.HexToAddress(ownerAddress)
	masterSigner := common.HexToAddress(masterSignerAddress)

	// Call the AccountManager contract's getAccountAddress function
	accountAddress, err := c.accountManager.GetAccountAddress(&bind.CallOpts{Context: ctx}, owner, masterSigner)
	if err != nil {
		return "", fmt.Errorf("failed to get account address from AccountManager: %w", err)
	}

	return accountAddress.Hex(), nil
}

// IsAccountDeployed checks if an account is already deployed on the blockchain
func (c *CPOPClient) IsAccountDeployed(ctx context.Context, ownerAddress string, masterSignerAddress string) (bool, error) {
	// Convert string addresses to common.Address
	owner := common.HexToAddress(ownerAddress)
	masterSigner := common.HexToAddress(masterSignerAddress)

	// Call the AccountManager contract's isAccountDeployed function
	isDeployed, err := c.accountManager.IsAccountDeployed(&bind.CallOpts{Context: ctx}, owner, masterSigner)
	if err != nil {
		return false, fmt.Errorf("failed to check account deployment status: %w", err)
	}

	return isDeployed, nil
}

// DeployAccount deploys an AA account to the blockchain
func (c *CPOPClient) DeployAccount(ctx context.Context, privateKey *ecdsa.PrivateKey, ownerAddress string, salt *big.Int) (*DeploymentResult, error) {
	// For now, simulate account deployment
	// In production, this should call the actual AccountManager contract's createAccount function

	// Calculate account address
	accountAddress, err := c.CreateAccountAddress(ctx, ownerAddress, salt)
	if err != nil {
		return nil, fmt.Errorf("failed to get account address: %w", err)
	}

	// Generate a mock transaction hash
	hashData := fmt.Sprintf("deploy-%s-%s", ownerAddress, salt.String())
	txHash := crypto.Keccak256Hash([]byte(hashData))

	// Get gas price for estimation
	gasPrice, err := c.client.SuggestGasPrice(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get gas price: %w", err)
	}

	// Apply gas price factor
	adjustedGasPrice := new(big.Int).Mul(gasPrice, big.NewInt(int64(c.config.GasPriceFactor*100)))
	adjustedGasPrice = adjustedGasPrice.Div(adjustedGasPrice, big.NewInt(100))

	return &DeploymentResult{
		TxHash:         txHash.Hex(),
		AccountAddress: accountAddress,
		GasUsed:        c.config.DefaultGasLimit,
		GasPrice:       adjustedGasPrice,
	}, nil
}

// EstimateAccountDeploymentCost estimates the cost of deploying a account
func (c *CPOPClient) EstimateAccountDeploymentCost(ctx context.Context, ownerAddress string) (*CostEstimate, error) {
	// Get current gas price
	gasPrice, err := c.client.SuggestGasPrice(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get gas price: %w", err)
	}

	// Apply gas price factor
	adjustedGasPrice := new(big.Int).Mul(gasPrice, big.NewInt(int64(c.config.GasPriceFactor*100)))
	adjustedGasPrice = adjustedGasPrice.Div(adjustedGasPrice, big.NewInt(100))

	// Use configured gas limit for estimation
	gasLimit := c.config.DefaultGasLimit

	totalCost := new(big.Int).Mul(adjustedGasPrice, new(big.Int).SetUint64(gasLimit))

	return &CostEstimate{
		GasLimit:     gasLimit,
		GasPrice:     adjustedGasPrice,
		TotalCostWei: totalCost,
		TotalCostETH: weiToEther(totalCost),
	}, nil
}

// weiToEther converts wei to ether string representation
func weiToEther(wei *big.Int) string {
	ether := new(big.Float).Quo(new(big.Float).SetInt(wei), big.NewFloat(1e18))
	return ether.Text('f', 6)
}

// GetDeploymentPrivateKey retrieves deployment private key for the chain from key string
func GetDeploymentPrivateKeyFromString(keyString string) (*ecdsa.PrivateKey, error) {
	if keyString == "" {
		return nil, fmt.Errorf("deployment private key is empty")
	}

	// Remove 0x prefix if present
	if len(keyString) > 2 && keyString[:2] == "0x" {
		keyString = keyString[2:]
	}

	return crypto.HexToECDSA(keyString)
}

// GenerateAccountSalt creates a deterministic salt for account address generation
func GenerateAccountSalt(userID string, chainID int64) *big.Int {
	// Create deterministic salt to ensure same user gets same account address on same chain
	data := fmt.Sprintf("%s-%d", userID, chainID)
	hash := crypto.Keccak256Hash([]byte(data))
	return new(big.Int).SetBytes(hash[:])
}

// GenerateOwnerAddress generates a deterministic owner address using off-chain algorithm
func GenerateOwnerAddress(userID string, chainID int64) string {
	// Create deterministic data based on userID and chainID
	data := fmt.Sprintf("owner-%s-%d", userID, chainID)

	// Generate hash and use first 20 bytes as address
	hash := crypto.Keccak256Hash([]byte(data))

	// Take the last 20 bytes of the hash to form an Ethereum address
	address := common.BytesToAddress(hash.Bytes()[12:32])

	return address.Hex()
}
