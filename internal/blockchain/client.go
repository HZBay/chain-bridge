// Code generated by "make swagger"; DO NOT EDIT.
package blockchain

import (
	"context"
	"crypto/ecdsa"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
)

// CPOPClient handles interaction with CPOP account abstraction contracts
type CPOPClient struct {
	client  *ethclient.Client
	chainID *big.Int

	// Configuration
	config CPOPConfig
}

// CPOPConfig contains configuration for CPOP blockchain client
type CPOPConfig struct {
	RPCEndpoint          string
	WalletManagerAddress common.Address
	EntryPointAddress    common.Address
	GasPriceFactor       float64
	DefaultGasLimit      uint64
}

// DeploymentResult contains result of wallet deployment
type DeploymentResult struct {
	TxHash        string
	WalletAddress string
	GasUsed       uint64
	GasPrice      *big.Int
}

// CostEstimate contains gas cost estimation
type CostEstimate struct {
	GasLimit     uint64
	GasPrice     *big.Int
	TotalCostWei *big.Int
	TotalCostETH string
}

// NewCPOPClient creates a new CPOP blockchain client
func NewCPOPClient(config CPOPConfig) (*CPOPClient, error) {
	client, err := ethclient.Dial(config.RPCEndpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to blockchain: %w", err)
	}

	chainID, err := client.ChainID(context.Background())
	if err != nil {
		return nil, fmt.Errorf("failed to get chain ID: %w", err)
	}

	return &CPOPClient{
		client:  client,
		chainID: chainID,
		config:  config,
	}, nil
}

// CreateWalletAddress generates a deterministic wallet address using CREATE2
func (c *CPOPClient) CreateWalletAddress(ctx context.Context, ownerAddress string, salt *big.Int) (string, error) {
	// For now, we'll generate a deterministic address based on owner and salt
	// In production, this should use the actual WalletManager contract's getAddress function
	owner := common.HexToAddress(ownerAddress)

	// Simple deterministic address generation (placeholder implementation)
	data := append(owner.Bytes(), salt.Bytes()...)
	hash := crypto.Keccak256Hash(data)
	walletAddress := common.BytesToAddress(hash.Bytes()[:20])

	return walletAddress.Hex(), nil
}

// DeployWallet deploys an AA wallet to the blockchain
func (c *CPOPClient) DeployWallet(ctx context.Context, privateKey *ecdsa.PrivateKey, ownerAddress string, salt *big.Int) (*DeploymentResult, error) {
	// For now, simulate wallet deployment
	// In production, this should call the actual WalletManager contract's createAccount function

	// Calculate wallet address
	walletAddress, err := c.CreateWalletAddress(ctx, ownerAddress, salt)
	if err != nil {
		return nil, fmt.Errorf("failed to get wallet address: %w", err)
	}

	// Generate a mock transaction hash
	hashData := fmt.Sprintf("deploy-%s-%s", ownerAddress, salt.String())
	txHash := crypto.Keccak256Hash([]byte(hashData))

	// Get gas price for estimation
	gasPrice, err := c.client.SuggestGasPrice(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get gas price: %w", err)
	}

	// Apply gas price factor
	adjustedGasPrice := new(big.Int).Mul(gasPrice, big.NewInt(int64(c.config.GasPriceFactor*100)))
	adjustedGasPrice = adjustedGasPrice.Div(adjustedGasPrice, big.NewInt(100))

	return &DeploymentResult{
		TxHash:        txHash.Hex(),
		WalletAddress: walletAddress,
		GasUsed:       c.config.DefaultGasLimit,
		GasPrice:      adjustedGasPrice,
	}, nil
}

// EstimateWalletDeploymentCost estimates the cost of deploying a wallet
func (c *CPOPClient) EstimateWalletDeploymentCost(ctx context.Context, ownerAddress string) (*CostEstimate, error) {
	// Get current gas price
	gasPrice, err := c.client.SuggestGasPrice(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get gas price: %w", err)
	}

	// Apply gas price factor
	adjustedGasPrice := new(big.Int).Mul(gasPrice, big.NewInt(int64(c.config.GasPriceFactor*100)))
	adjustedGasPrice = adjustedGasPrice.Div(adjustedGasPrice, big.NewInt(100))

	// Use configured gas limit for estimation
	gasLimit := c.config.DefaultGasLimit

	totalCost := new(big.Int).Mul(adjustedGasPrice, new(big.Int).SetUint64(gasLimit))

	return &CostEstimate{
		GasLimit:     gasLimit,
		GasPrice:     adjustedGasPrice,
		TotalCostWei: totalCost,
		TotalCostETH: weiToEther(totalCost),
	}, nil
}

// weiToEther converts wei to ether string representation
func weiToEther(wei *big.Int) string {
	ether := new(big.Float).Quo(new(big.Float).SetInt(wei), big.NewFloat(1e18))
	return ether.Text('f', 6)
}

// GetDeploymentPrivateKey retrieves deployment private key for the chain from key string
func GetDeploymentPrivateKeyFromString(keyString string) (*ecdsa.PrivateKey, error) {
	if keyString == "" {
		return nil, fmt.Errorf("deployment private key is empty")
	}

	// Remove 0x prefix if present
	if len(keyString) > 2 && keyString[:2] == "0x" {
		keyString = keyString[2:]
	}

	return crypto.HexToECDSA(keyString)
}

// GenerateWalletSalt creates a deterministic salt for wallet address generation
func GenerateWalletSalt(userID string, chainID int64) *big.Int {
	// Create deterministic salt to ensure same user gets same wallet address on same chain
	data := fmt.Sprintf("%s-%d", userID, chainID)
	hash := crypto.Keccak256Hash([]byte(data))
	return new(big.Int).SetBytes(hash[:])
}
