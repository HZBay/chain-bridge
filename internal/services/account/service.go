// Code generated by "make swagger"; DO NOT EDIT.
package account

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/go-openapi/strfmt"
	"github.com/hzbay/chain-bridge/internal/blockchain"
	"github.com/hzbay/chain-bridge/internal/config"
	"github.com/hzbay/chain-bridge/internal/models"
	"github.com/hzbay/chain-bridge/internal/services/chains"
	"github.com/hzbay/chain-bridge/internal/types"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

// Service defines the account service interface
type Service interface {
	GetUserAccounts(ctx context.Context, userID string) (*types.AccountResponse, error)
	CreateAccount(ctx context.Context, userID string, req *types.CreateAccountRequest) (*types.CreateAccountResponse, error)
	DeployAccount(ctx context.Context, userID string, req *types.DeployAccountRequest) (*types.DeployAccountResponse, error)
}

// service implements the account service
type service struct {
	db               *sql.DB
	cpopClients      map[int64]*blockchain.CPOPClient // indexed by chainID
	blockchainConfig config.BlockchainConfig
	chainsService    chains.Service // 用于获取链配置
}

// NewService creates a new account service
func NewService(db *sql.DB, blockchainConfig config.BlockchainConfig, chainsService chains.Service) (Service, error) {
	// 通过 chainsService 获取 CPOP 配置
	cpopConfigs, err := chainsService.GetCPOPConfigs(context.Background())
	if err != nil {
		return nil, fmt.Errorf("failed to load CPOP configs: %w", err)
	}

	cpopClients := make(map[int64]*blockchain.CPOPClient)
	for chainID, cpopConfig := range cpopConfigs {
		client, err := blockchain.NewCPOPClient(cpopConfig)
		if err != nil {
			return nil, fmt.Errorf("failed to create CPOP client for chain %d: %w", chainID, err)
		}
		cpopClients[chainID] = client
	}

	return &service{
		db:               db,
		cpopClients:      cpopClients,
		blockchainConfig: blockchainConfig,
		chainsService:    chainsService, // 保持引用用于运行时更新
	}, nil
}

// GetUserAccounts retrieves all accounts for a user
func (s *service) GetUserAccounts(ctx context.Context, userID string) (*types.AccountResponse, error) {
	// Query user accounts from database
	accounts, err := models.UserAccounts(
		models.UserAccountWhere.UserID.EQ(userID),
		qm.Load(models.UserAccountRels.Chain),
		qm.OrderBy(models.UserAccountColumns.CreatedAt+" DESC"),
	).All(ctx, s.db)
	if err != nil {
		return nil, fmt.Errorf("failed to query user accounts: %w", err)
	}

	// Convert to response format
	response := &types.AccountResponse{
		UserID:   &userID,
		Accounts: make([]*types.AccountInfo, len(accounts)),
	}

	for i, account := range accounts {
		accountID := int64(account.ID)
		chainID := account.ChainID
		isDeployed := account.IsDeployed.Bool

		accountInfo := &types.AccountInfo{
			ID:         &accountID,
			UserID:     &account.UserID,
			ChainID:    &chainID,
			AaAddress:  &account.AaAddress,
			Owner:      &account.Owner,
			IsDeployed: &isDeployed,
		}

		// Add chain name if available
		if account.R != nil && account.R.Chain != nil {
			accountInfo.ChainName = account.R.Chain.Name
		}

		// Add deployment info if available
		if account.DeploymentTXHash.Valid {
			accountInfo.DeploymentTxHash = account.DeploymentTXHash.String
		}
		if account.MasterSigner.Valid {
			accountInfo.MasterSigner = account.MasterSigner.String
		}
		if account.CreatedAt.Valid {
			createdAt := strfmt.DateTime(account.CreatedAt.Time)
			accountInfo.CreatedAt = createdAt
		}

		response.Accounts[i] = accountInfo
	}

	return response, nil
}

// CreateAccount creates a new account (address generation only, no deployment)
func (s *service) CreateAccount(ctx context.Context, userID string, req *types.CreateAccountRequest) (*types.CreateAccountResponse, error) {
	// Request validation is handled at handler layer

	chainID := *req.ChainID

	// Generate owner address if not provided
	var ownerAddress string
	if req.OwnerAddress == "" {
		// Use off-chain algorithm to generate deterministic owner address
		ownerAddress = blockchain.GenerateOwnerAddress(userID, chainID)
	} else {
		ownerAddress = req.OwnerAddress
	}

	// Validate chain is supported
	cpopClient, exists := s.cpopClients[chainID]
	if !exists {
		return nil, fmt.Errorf("chain %d not supported", chainID)
	}

	// Check if account already exists
	exists, err := models.UserAccounts(
		models.UserAccountWhere.UserID.EQ(userID),
		models.UserAccountWhere.ChainID.EQ(chainID),
	).Exists(ctx, s.db)
	if err != nil {
		return nil, fmt.Errorf("failed to check account existence: %w", err)
	}
	if exists {
		return nil, fmt.Errorf("account already exists for user %s on chain %d", userID, chainID)
	}

	// Generate deterministic salt (based on userID and chainID)
	salt := blockchain.GenerateAccountSalt(userID, chainID)

	// Calculate AA account address (CREATE2 deterministic address)
	aaAddress, err := cpopClient.CreateAccountAddress(ctx, ownerAddress, salt)
	if err != nil {
		return nil, fmt.Errorf("failed to create account address: %w", err)
	}

	// Save to database (not deployed state)
	account := &models.UserAccount{
		UserID:     userID,
		ChainID:    chainID,
		AaAddress:  aaAddress,
		Owner:      ownerAddress,
		IsDeployed: null.BoolFrom(false),
	}

	if err := account.Insert(ctx, s.db, boil.Infer()); err != nil {
		return nil, fmt.Errorf("failed to save account: %w", err)
	}

	return &types.CreateAccountResponse{
		UserID:         userID,
		ChainID:        chainID,
		AaAddress:      aaAddress,
		Owner:          ownerAddress,
		IsDeployed:     false,
		AccountCreated: true,
		BindingStatus:  "success",
	}, nil
}

// DeployAccount deploys an existing account to the blockchain
func (s *service) DeployAccount(ctx context.Context, userID string, req *types.DeployAccountRequest) (*types.DeployAccountResponse, error) {
	// Request validation is handled at handler layer

	chainID := *req.ChainID

	// Get account record
	account, err := models.UserAccounts(
		models.UserAccountWhere.UserID.EQ(userID),
		models.UserAccountWhere.ChainID.EQ(chainID),
	).One(ctx, s.db)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("account not found for user %s on chain %d", userID, chainID)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to query account: %w", err)
	}

	// Check if already deployed
	if account.IsDeployed.Bool {
		return nil, fmt.Errorf("account already deployed")
	}

	// Get CPOP client
	cpopClient, exists := s.cpopClients[chainID]
	if !exists {
		return nil, fmt.Errorf("chain %d not supported", chainID)
	}

	// Estimate deployment cost
	costEstimate, err := cpopClient.EstimateAccountDeploymentCost(ctx, account.Owner)
	if err != nil {
		return nil, fmt.Errorf("failed to estimate deployment cost: %w", err)
	}

	// Get unified deployment private key from config
	keyString, err := s.blockchainConfig.GetUnifiedDeploymentPrivateKey()
	if err != nil {
		return nil, fmt.Errorf("failed to get unified deployment key: %w", err)
	}

	privateKey, err := blockchain.GetDeploymentPrivateKeyFromString(keyString)
	if err != nil {
		return nil, fmt.Errorf("failed to parse deployment key: %w", err)
	}

	// Execute deployment
	salt := blockchain.GenerateAccountSalt(userID, chainID)
	result, err := cpopClient.DeployAccount(ctx, privateKey, account.Owner, salt)
	if err != nil {
		return nil, fmt.Errorf("failed to deploy account: %w", err)
	}

	// Update database status
	account.DeploymentTXHash = null.StringFrom(result.TxHash)
	account.IsDeployed = null.BoolFrom(true) // Simplified: actual implementation should monitor tx confirmation

	if _, err := account.Update(ctx, s.db, boil.Infer()); err != nil {
		return nil, fmt.Errorf("failed to update account status: %w", err)
	}

	deploymentStatus := "submitted"
	estimatedGasCost := costEstimate.TotalCostETH + " ETH"
	estimatedConfirmationTime := "2-5 minutes"

	return &types.DeployAccountResponse{
		UserID:                    &userID,
		ChainID:                   &chainID,
		AaAddress:                 &account.AaAddress,
		DeploymentStatus:          &deploymentStatus,
		DeploymentTxHash:          result.TxHash,
		EstimatedGasCost:          estimatedGasCost,
		EstimatedConfirmationTime: estimatedConfirmationTime,
	}, nil
}
