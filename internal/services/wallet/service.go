// Code generated by "make swagger"; DO NOT EDIT.
package wallet

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/go-openapi/strfmt"
	"github.com/hzbay/chain-bridge/internal/blockchain"
	"github.com/hzbay/chain-bridge/internal/config"
	"github.com/hzbay/chain-bridge/internal/models"
	"github.com/hzbay/chain-bridge/internal/types"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
)

// Service defines the wallet service interface
type Service interface {
	GetUserWallets(ctx context.Context, userID string) (*types.WalletResponse, error)
	CreateWallet(ctx context.Context, userID string, req *types.CreateWalletRequest) (*types.CreateWalletResponse, error)
	DeployWallet(ctx context.Context, userID string, req *types.DeployWalletRequest) (*types.DeployWalletResponse, error)
}

// service implements the wallet service
type service struct {
	db               *sql.DB
	cpopClients      map[int64]*blockchain.CPOPClient // indexed by chainID
	blockchainConfig config.BlockchainConfig
}

// NewService creates a new wallet service
func NewService(db *sql.DB, chainConfigs map[int64]blockchain.CPOPConfig, blockchainConfig config.BlockchainConfig) (Service, error) {
	cpopClients := make(map[int64]*blockchain.CPOPClient)

	for chainID, config := range chainConfigs {
		client, err := blockchain.NewCPOPClient(config)
		if err != nil {
			return nil, fmt.Errorf("failed to create CPOP client for chain %d: %w", chainID, err)
		}
		cpopClients[chainID] = client
	}

	return &service{
		db:               db,
		cpopClients:      cpopClients,
		blockchainConfig: blockchainConfig,
	}, nil
}

// GetUserWallets retrieves all wallets for a user
func (s *service) GetUserWallets(ctx context.Context, userID string) (*types.WalletResponse, error) {
	// Query user wallets from database
	wallets, err := models.UserWallets(
		models.UserWalletWhere.UserID.EQ(userID),
		qm.Load(models.UserWalletRels.Chain),
		qm.OrderBy(models.UserWalletColumns.CreatedAt+" DESC"),
	).All(ctx, s.db)
	if err != nil {
		return nil, fmt.Errorf("failed to query user wallets: %w", err)
	}

	// Convert to response format
	response := &types.WalletResponse{
		UserID:  &userID,
		Wallets: make([]*types.WalletInfo, len(wallets)),
	}

	for i, wallet := range wallets {
		walletID := int64(wallet.ID)
		chainID := wallet.ChainID
		isDeployed := wallet.IsDeployed.Bool

		walletInfo := &types.WalletInfo{
			ID:         &walletID,
			UserID:     &wallet.UserID,
			ChainID:    &chainID,
			AaAddress:  &wallet.AaAddress,
			Owner:      &wallet.Owner,
			IsDeployed: &isDeployed,
		}

		// Add chain name if available
		if wallet.R != nil && wallet.R.Chain != nil {
			walletInfo.ChainName = wallet.R.Chain.Name
		}

		// Add deployment info if available
		if wallet.DeploymentTXHash.Valid {
			walletInfo.DeploymentTxHash = wallet.DeploymentTXHash.String
		}
		if wallet.MasterSigner.Valid {
			walletInfo.MasterSigner = wallet.MasterSigner.String
		}
		if wallet.CreatedAt.Valid {
			createdAt := strfmt.DateTime(wallet.CreatedAt.Time)
			walletInfo.CreatedAt = createdAt
		}

		response.Wallets[i] = walletInfo
	}

	return response, nil
}

// CreateWallet creates a new wallet (address generation only, no deployment)
func (s *service) CreateWallet(ctx context.Context, userID string, req *types.CreateWalletRequest) (*types.CreateWalletResponse, error) {
	// Validate request parameters
	if req.ChainID == nil {
		return nil, fmt.Errorf("chain_id is required")
	}
	if req.OwnerAddress == nil {
		return nil, fmt.Errorf("owner_address is required")
	}

	chainID := *req.ChainID
	ownerAddress := *req.OwnerAddress

	// Validate chain is supported
	cpopClient, exists := s.cpopClients[chainID]
	if !exists {
		return nil, fmt.Errorf("chain %d not supported", chainID)
	}

	// Check if wallet already exists
	exists, err := models.UserWallets(
		models.UserWalletWhere.UserID.EQ(userID),
		models.UserWalletWhere.ChainID.EQ(chainID),
	).Exists(ctx, s.db)
	if err != nil {
		return nil, fmt.Errorf("failed to check wallet existence: %w", err)
	}
	if exists {
		return nil, fmt.Errorf("wallet already exists for user %s on chain %d", userID, chainID)
	}

	// Generate deterministic salt (based on userID and chainID)
	salt := blockchain.GenerateWalletSalt(userID, chainID)

	// Calculate AA wallet address (CREATE2 deterministic address)
	aaAddress, err := cpopClient.CreateWalletAddress(ctx, ownerAddress, salt)
	if err != nil {
		return nil, fmt.Errorf("failed to create wallet address: %w", err)
	}

	// Save to database (not deployed state)
	wallet := &models.UserWallet{
		UserID:     userID,
		ChainID:    chainID,
		AaAddress:  aaAddress,
		Owner:      ownerAddress,
		IsDeployed: null.BoolFrom(false),
	}

	if err := wallet.Insert(ctx, s.db, boil.Infer()); err != nil {
		return nil, fmt.Errorf("failed to save wallet: %w", err)
	}

	return &types.CreateWalletResponse{
		UserID:        userID,
		ChainID:       chainID,
		AaAddress:     aaAddress,
		Owner:         ownerAddress,
		IsDeployed:    false,
		WalletCreated: true,
		BindingStatus: "success",
	}, nil
}

// DeployWallet deploys an existing wallet to the blockchain
func (s *service) DeployWallet(ctx context.Context, userID string, req *types.DeployWalletRequest) (*types.DeployWalletResponse, error) {
	// Validate request parameters
	if req.ChainID == nil {
		return nil, fmt.Errorf("chain_id is required")
	}

	chainID := *req.ChainID

	// Get wallet record
	wallet, err := models.UserWallets(
		models.UserWalletWhere.UserID.EQ(userID),
		models.UserWalletWhere.ChainID.EQ(chainID),
	).One(ctx, s.db)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("wallet not found for user %s on chain %d", userID, chainID)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to query wallet: %w", err)
	}

	// Check if already deployed
	if wallet.IsDeployed.Bool {
		return nil, fmt.Errorf("wallet already deployed")
	}

	// Get CPOP client
	cpopClient, exists := s.cpopClients[chainID]
	if !exists {
		return nil, fmt.Errorf("chain %d not supported", chainID)
	}

	// Estimate deployment cost
	costEstimate, err := cpopClient.EstimateWalletDeploymentCost(ctx, wallet.Owner)
	if err != nil {
		return nil, fmt.Errorf("failed to estimate deployment cost: %w", err)
	}

	// Get deployment private key from config
	keyString, err := s.blockchainConfig.GetDeploymentPrivateKey(chainID)
	if err != nil {
		return nil, fmt.Errorf("failed to get deployment key: %w", err)
	}

	privateKey, err := blockchain.GetDeploymentPrivateKeyFromString(keyString)
	if err != nil {
		return nil, fmt.Errorf("failed to parse deployment key: %w", err)
	}

	// Execute deployment
	salt := blockchain.GenerateWalletSalt(userID, chainID)
	result, err := cpopClient.DeployWallet(ctx, privateKey, wallet.Owner, salt)
	if err != nil {
		return nil, fmt.Errorf("failed to deploy wallet: %w", err)
	}

	// Update database status
	wallet.DeploymentTXHash = null.StringFrom(result.TxHash)
	wallet.IsDeployed = null.BoolFrom(true) // Simplified: actual implementation should monitor tx confirmation

	if _, err := wallet.Update(ctx, s.db, boil.Infer()); err != nil {
		return nil, fmt.Errorf("failed to update wallet status: %w", err)
	}

	deploymentStatus := "submitted"
	estimatedGasCost := costEstimate.TotalCostETH + " ETH"
	estimatedConfirmationTime := "2-5 minutes"

	return &types.DeployWalletResponse{
		UserID:                    &userID,
		ChainID:                   &chainID,
		AaAddress:                 &wallet.AaAddress,
		DeploymentStatus:          &deploymentStatus,
		DeploymentTxHash:          result.TxHash,
		EstimatedGasCost:          estimatedGasCost,
		EstimatedConfirmationTime: estimatedConfirmationTime,
	}, nil
}
