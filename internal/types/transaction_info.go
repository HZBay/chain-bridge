// Code generated by go-swagger; DO NOT EDIT.

package types

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TransactionInfo transaction info
//
// swagger:model transactionInfo
type TransactionInfo struct {

	// Transaction amount (positive/negative)
	// Example: -50.000000000000000000
	// Required: true
	Amount *string `json:"amount"`

	// Amount in USD
	// Example: -2.50
	AmountUsd string `json:"amount_usd,omitempty"`

	// Batch ID if batched
	// Example: batch_transfer_001
	BatchID string `json:"batch_id,omitempty"`

	// Block number
	BlockNumber int64 `json:"block_number,omitempty"`

	// Business type
	// Required: true
	// Enum: [transfer reward gas_fee consumption refund]
	BusinessType *string `json:"business_type"`

	// Chain ID
	// Example: 56
	// Required: true
	ChainID *int64 `json:"chain_id"`

	// Chain name
	// Example: BSC
	ChainName string `json:"chain_name,omitempty"`

	// Confirmation timestamp
	// Format: date-time
	ConfirmedAt strfmt.DateTime `json:"confirmed_at,omitempty"`

	// Creation timestamp
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

	// Gas saved percentage
	// Example: 76.8
	GasSavedPercentage float32 `json:"gas_saved_percentage,omitempty"`

	// Whether part of batch operation
	IsBatchOperation *bool `json:"is_batch_operation,omitempty"`

	// Business operation ID
	// Example: op_transfer_001
	OperationID string `json:"operation_id,omitempty"`

	// Detailed reason
	// Example: 朋友转账
	ReasonDetail string `json:"reason_detail,omitempty"`

	// Reason type
	// Example: user_transfer
	ReasonType string `json:"reason_type,omitempty"`

	// Related user ID (for transfers)
	// Example: user_456
	RelatedUserID string `json:"related_user_id,omitempty"`

	// Transaction status
	// Required: true
	// Enum: [pending batching submitted confirmed failed]
	Status *string `json:"status"`

	// Token symbol
	// Example: CPOP
	// Required: true
	TokenSymbol *string `json:"token_symbol"`

	// Transfer direction (only for transfers)
	// Enum: [outgoing incoming]
	TransferDirection string `json:"transfer_direction,omitempty"`

	// Blockchain transaction hash
	// Example: 0xabc123...
	TxHash string `json:"tx_hash,omitempty"`

	// Transaction ID
	// Example: tx_001
	// Required: true
	TxID *string `json:"tx_id"`

	// Transaction type
	// Required: true
	// Enum: [mint burn transfer]
	TxType *string `json:"tx_type"`
}

// Validate validates this transaction info
func (m *TransactionInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBusinessType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChainID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfirmedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTokenSymbol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransferDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionInfo) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount); err != nil {
		return err
	}

	return nil
}

var transactionInfoTypeBusinessTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["transfer","reward","gas_fee","consumption","refund"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionInfoTypeBusinessTypePropEnum = append(transactionInfoTypeBusinessTypePropEnum, v)
	}
}

const (

	// TransactionInfoBusinessTypeTransfer captures enum value "transfer"
	TransactionInfoBusinessTypeTransfer string = "transfer"

	// TransactionInfoBusinessTypeReward captures enum value "reward"
	TransactionInfoBusinessTypeReward string = "reward"

	// TransactionInfoBusinessTypeGasFee captures enum value "gas_fee"
	TransactionInfoBusinessTypeGasFee string = "gas_fee"

	// TransactionInfoBusinessTypeConsumption captures enum value "consumption"
	TransactionInfoBusinessTypeConsumption string = "consumption"

	// TransactionInfoBusinessTypeRefund captures enum value "refund"
	TransactionInfoBusinessTypeRefund string = "refund"
)

// prop value enum
func (m *TransactionInfo) validateBusinessTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionInfoTypeBusinessTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionInfo) validateBusinessType(formats strfmt.Registry) error {

	if err := validate.Required("business_type", "body", m.BusinessType); err != nil {
		return err
	}

	// value enum
	if err := m.validateBusinessTypeEnum("business_type", "body", *m.BusinessType); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInfo) validateChainID(formats strfmt.Registry) error {

	if err := validate.Required("chain_id", "body", m.ChainID); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInfo) validateConfirmedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfirmedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("confirmed_at", "body", "date-time", m.ConfirmedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInfo) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

var transactionInfoTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["pending","batching","submitted","confirmed","failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionInfoTypeStatusPropEnum = append(transactionInfoTypeStatusPropEnum, v)
	}
}

const (

	// TransactionInfoStatusPending captures enum value "pending"
	TransactionInfoStatusPending string = "pending"

	// TransactionInfoStatusBatching captures enum value "batching"
	TransactionInfoStatusBatching string = "batching"

	// TransactionInfoStatusSubmitted captures enum value "submitted"
	TransactionInfoStatusSubmitted string = "submitted"

	// TransactionInfoStatusConfirmed captures enum value "confirmed"
	TransactionInfoStatusConfirmed string = "confirmed"

	// TransactionInfoStatusFailed captures enum value "failed"
	TransactionInfoStatusFailed string = "failed"
)

// prop value enum
func (m *TransactionInfo) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionInfoTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionInfo) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInfo) validateTokenSymbol(formats strfmt.Registry) error {

	if err := validate.Required("token_symbol", "body", m.TokenSymbol); err != nil {
		return err
	}

	return nil
}

var transactionInfoTypeTransferDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["outgoing","incoming"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionInfoTypeTransferDirectionPropEnum = append(transactionInfoTypeTransferDirectionPropEnum, v)
	}
}

const (

	// TransactionInfoTransferDirectionOutgoing captures enum value "outgoing"
	TransactionInfoTransferDirectionOutgoing string = "outgoing"

	// TransactionInfoTransferDirectionIncoming captures enum value "incoming"
	TransactionInfoTransferDirectionIncoming string = "incoming"
)

// prop value enum
func (m *TransactionInfo) validateTransferDirectionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionInfoTypeTransferDirectionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionInfo) validateTransferDirection(formats strfmt.Registry) error {
	if swag.IsZero(m.TransferDirection) { // not required
		return nil
	}

	// value enum
	if err := m.validateTransferDirectionEnum("transfer_direction", "body", m.TransferDirection); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInfo) validateTxID(formats strfmt.Registry) error {

	if err := validate.Required("tx_id", "body", m.TxID); err != nil {
		return err
	}

	return nil
}

var transactionInfoTypeTxTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["mint","burn","transfer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionInfoTypeTxTypePropEnum = append(transactionInfoTypeTxTypePropEnum, v)
	}
}

const (

	// TransactionInfoTxTypeMint captures enum value "mint"
	TransactionInfoTxTypeMint string = "mint"

	// TransactionInfoTxTypeBurn captures enum value "burn"
	TransactionInfoTxTypeBurn string = "burn"

	// TransactionInfoTxTypeTransfer captures enum value "transfer"
	TransactionInfoTxTypeTransfer string = "transfer"
)

// prop value enum
func (m *TransactionInfo) validateTxTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionInfoTypeTxTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionInfo) validateTxType(formats strfmt.Registry) error {

	if err := validate.Required("tx_type", "body", m.TxType); err != nil {
		return err
	}

	// value enum
	if err := m.validateTxTypeEnum("tx_type", "body", *m.TxType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this transaction info based on context it is used
func (m *TransactionInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TransactionInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionInfo) UnmarshalBinary(b []byte) error {
	var res TransactionInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
