// Code generated by SQLBoiler 4.18.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// Transaction is an object representing the database table.
type Transaction struct {
	ID                 int               `boil:"id" json:"id" toml:"id" yaml:"id"`
	TXID               string            `boil:"tx_id" json:"tx_id" toml:"tx_id" yaml:"tx_id"`
	OperationID        null.String       `boil:"operation_id" json:"operation_id,omitempty" toml:"operation_id" yaml:"operation_id,omitempty"`
	UserID             string            `boil:"user_id" json:"user_id" toml:"user_id" yaml:"user_id"`
	ChainID            int64             `boil:"chain_id" json:"chain_id" toml:"chain_id" yaml:"chain_id"`
	TXType             string            `boil:"tx_type" json:"tx_type" toml:"tx_type" yaml:"tx_type"`
	BusinessType       string            `boil:"business_type" json:"business_type" toml:"business_type" yaml:"business_type"`
	RelatedUserID      null.String       `boil:"related_user_id" json:"related_user_id,omitempty" toml:"related_user_id" yaml:"related_user_id,omitempty"`
	TransferDirection  null.String       `boil:"transfer_direction" json:"transfer_direction,omitempty" toml:"transfer_direction" yaml:"transfer_direction,omitempty"`
	TokenID            int               `boil:"token_id" json:"token_id" toml:"token_id" yaml:"token_id"`
	Amount             types.Decimal     `boil:"amount" json:"amount" toml:"amount" yaml:"amount"`
	AmountUsd          types.NullDecimal `boil:"amount_usd" json:"amount_usd,omitempty" toml:"amount_usd" yaml:"amount_usd,omitempty"`
	Status             null.String       `boil:"status" json:"status,omitempty" toml:"status" yaml:"status,omitempty"`
	TXHash             null.String       `boil:"tx_hash" json:"tx_hash,omitempty" toml:"tx_hash" yaml:"tx_hash,omitempty"`
	BlockNumber        null.Int64        `boil:"block_number" json:"block_number,omitempty" toml:"block_number" yaml:"block_number,omitempty"`
	BatchID            null.String       `boil:"batch_id" json:"batch_id,omitempty" toml:"batch_id" yaml:"batch_id,omitempty"`
	IsBatchOperation   null.Bool         `boil:"is_batch_operation" json:"is_batch_operation,omitempty" toml:"is_batch_operation" yaml:"is_batch_operation,omitempty"`
	GasSavedPercentage types.NullDecimal `boil:"gas_saved_percentage" json:"gas_saved_percentage,omitempty" toml:"gas_saved_percentage" yaml:"gas_saved_percentage,omitempty"`
	ReasonType         string            `boil:"reason_type" json:"reason_type" toml:"reason_type" yaml:"reason_type"`
	ReasonDetail       null.String       `boil:"reason_detail" json:"reason_detail,omitempty" toml:"reason_detail" yaml:"reason_detail,omitempty"`
	Metadata           null.JSON         `boil:"metadata" json:"metadata,omitempty" toml:"metadata" yaml:"metadata,omitempty"`
	CreatedAt          null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	ConfirmedAt        null.Time         `boil:"confirmed_at" json:"confirmed_at,omitempty" toml:"confirmed_at" yaml:"confirmed_at,omitempty"`
	FailureReason      null.String       `boil:"failure_reason" json:"failure_reason,omitempty" toml:"failure_reason" yaml:"failure_reason,omitempty"`
	UpdatedAt          null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`

	R *transactionR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L transactionL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var TransactionColumns = struct {
	ID                 string
	TXID               string
	OperationID        string
	UserID             string
	ChainID            string
	TXType             string
	BusinessType       string
	RelatedUserID      string
	TransferDirection  string
	TokenID            string
	Amount             string
	AmountUsd          string
	Status             string
	TXHash             string
	BlockNumber        string
	BatchID            string
	IsBatchOperation   string
	GasSavedPercentage string
	ReasonType         string
	ReasonDetail       string
	Metadata           string
	CreatedAt          string
	ConfirmedAt        string
	FailureReason      string
	UpdatedAt          string
}{
	ID:                 "id",
	TXID:               "tx_id",
	OperationID:        "operation_id",
	UserID:             "user_id",
	ChainID:            "chain_id",
	TXType:             "tx_type",
	BusinessType:       "business_type",
	RelatedUserID:      "related_user_id",
	TransferDirection:  "transfer_direction",
	TokenID:            "token_id",
	Amount:             "amount",
	AmountUsd:          "amount_usd",
	Status:             "status",
	TXHash:             "tx_hash",
	BlockNumber:        "block_number",
	BatchID:            "batch_id",
	IsBatchOperation:   "is_batch_operation",
	GasSavedPercentage: "gas_saved_percentage",
	ReasonType:         "reason_type",
	ReasonDetail:       "reason_detail",
	Metadata:           "metadata",
	CreatedAt:          "created_at",
	ConfirmedAt:        "confirmed_at",
	FailureReason:      "failure_reason",
	UpdatedAt:          "updated_at",
}

var TransactionTableColumns = struct {
	ID                 string
	TXID               string
	OperationID        string
	UserID             string
	ChainID            string
	TXType             string
	BusinessType       string
	RelatedUserID      string
	TransferDirection  string
	TokenID            string
	Amount             string
	AmountUsd          string
	Status             string
	TXHash             string
	BlockNumber        string
	BatchID            string
	IsBatchOperation   string
	GasSavedPercentage string
	ReasonType         string
	ReasonDetail       string
	Metadata           string
	CreatedAt          string
	ConfirmedAt        string
	FailureReason      string
	UpdatedAt          string
}{
	ID:                 "transactions.id",
	TXID:               "transactions.tx_id",
	OperationID:        "transactions.operation_id",
	UserID:             "transactions.user_id",
	ChainID:            "transactions.chain_id",
	TXType:             "transactions.tx_type",
	BusinessType:       "transactions.business_type",
	RelatedUserID:      "transactions.related_user_id",
	TransferDirection:  "transactions.transfer_direction",
	TokenID:            "transactions.token_id",
	Amount:             "transactions.amount",
	AmountUsd:          "transactions.amount_usd",
	Status:             "transactions.status",
	TXHash:             "transactions.tx_hash",
	BlockNumber:        "transactions.block_number",
	BatchID:            "transactions.batch_id",
	IsBatchOperation:   "transactions.is_batch_operation",
	GasSavedPercentage: "transactions.gas_saved_percentage",
	ReasonType:         "transactions.reason_type",
	ReasonDetail:       "transactions.reason_detail",
	Metadata:           "transactions.metadata",
	CreatedAt:          "transactions.created_at",
	ConfirmedAt:        "transactions.confirmed_at",
	FailureReason:      "transactions.failure_reason",
	UpdatedAt:          "transactions.updated_at",
}

// Generated where

type whereHelpertypes_Decimal struct{ field string }

func (w whereHelpertypes_Decimal) EQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_Decimal) NEQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_Decimal) LT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Decimal) LTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Decimal) GT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Decimal) GTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var TransactionWhere = struct {
	ID                 whereHelperint
	TXID               whereHelperstring
	OperationID        whereHelpernull_String
	UserID             whereHelperstring
	ChainID            whereHelperint64
	TXType             whereHelperstring
	BusinessType       whereHelperstring
	RelatedUserID      whereHelpernull_String
	TransferDirection  whereHelpernull_String
	TokenID            whereHelperint
	Amount             whereHelpertypes_Decimal
	AmountUsd          whereHelpertypes_NullDecimal
	Status             whereHelpernull_String
	TXHash             whereHelpernull_String
	BlockNumber        whereHelpernull_Int64
	BatchID            whereHelpernull_String
	IsBatchOperation   whereHelpernull_Bool
	GasSavedPercentage whereHelpertypes_NullDecimal
	ReasonType         whereHelperstring
	ReasonDetail       whereHelpernull_String
	Metadata           whereHelpernull_JSON
	CreatedAt          whereHelpernull_Time
	ConfirmedAt        whereHelpernull_Time
	FailureReason      whereHelpernull_String
	UpdatedAt          whereHelpernull_Time
}{
	ID:                 whereHelperint{field: "\"transactions\".\"id\""},
	TXID:               whereHelperstring{field: "\"transactions\".\"tx_id\""},
	OperationID:        whereHelpernull_String{field: "\"transactions\".\"operation_id\""},
	UserID:             whereHelperstring{field: "\"transactions\".\"user_id\""},
	ChainID:            whereHelperint64{field: "\"transactions\".\"chain_id\""},
	TXType:             whereHelperstring{field: "\"transactions\".\"tx_type\""},
	BusinessType:       whereHelperstring{field: "\"transactions\".\"business_type\""},
	RelatedUserID:      whereHelpernull_String{field: "\"transactions\".\"related_user_id\""},
	TransferDirection:  whereHelpernull_String{field: "\"transactions\".\"transfer_direction\""},
	TokenID:            whereHelperint{field: "\"transactions\".\"token_id\""},
	Amount:             whereHelpertypes_Decimal{field: "\"transactions\".\"amount\""},
	AmountUsd:          whereHelpertypes_NullDecimal{field: "\"transactions\".\"amount_usd\""},
	Status:             whereHelpernull_String{field: "\"transactions\".\"status\""},
	TXHash:             whereHelpernull_String{field: "\"transactions\".\"tx_hash\""},
	BlockNumber:        whereHelpernull_Int64{field: "\"transactions\".\"block_number\""},
	BatchID:            whereHelpernull_String{field: "\"transactions\".\"batch_id\""},
	IsBatchOperation:   whereHelpernull_Bool{field: "\"transactions\".\"is_batch_operation\""},
	GasSavedPercentage: whereHelpertypes_NullDecimal{field: "\"transactions\".\"gas_saved_percentage\""},
	ReasonType:         whereHelperstring{field: "\"transactions\".\"reason_type\""},
	ReasonDetail:       whereHelpernull_String{field: "\"transactions\".\"reason_detail\""},
	Metadata:           whereHelpernull_JSON{field: "\"transactions\".\"metadata\""},
	CreatedAt:          whereHelpernull_Time{field: "\"transactions\".\"created_at\""},
	ConfirmedAt:        whereHelpernull_Time{field: "\"transactions\".\"confirmed_at\""},
	FailureReason:      whereHelpernull_String{field: "\"transactions\".\"failure_reason\""},
	UpdatedAt:          whereHelpernull_Time{field: "\"transactions\".\"updated_at\""},
}

// TransactionRels is where relationship names are stored.
var TransactionRels = struct {
	Chain string
	Token string
}{
	Chain: "Chain",
	Token: "Token",
}

// transactionR is where relationships are stored.
type transactionR struct {
	Chain *Chain          `boil:"Chain" json:"Chain" toml:"Chain" yaml:"Chain"`
	Token *SupportedToken `boil:"Token" json:"Token" toml:"Token" yaml:"Token"`
}

// NewStruct creates a new relationship struct
func (*transactionR) NewStruct() *transactionR {
	return &transactionR{}
}

func (r *transactionR) GetChain() *Chain {
	if r == nil {
		return nil
	}
	return r.Chain
}

func (r *transactionR) GetToken() *SupportedToken {
	if r == nil {
		return nil
	}
	return r.Token
}

// transactionL is where Load methods for each relationship are stored.
type transactionL struct{}

var (
	transactionAllColumns            = []string{"id", "tx_id", "operation_id", "user_id", "chain_id", "tx_type", "business_type", "related_user_id", "transfer_direction", "token_id", "amount", "amount_usd", "status", "tx_hash", "block_number", "batch_id", "is_batch_operation", "gas_saved_percentage", "reason_type", "reason_detail", "metadata", "created_at", "confirmed_at", "failure_reason", "updated_at"}
	transactionColumnsWithoutDefault = []string{"tx_id", "user_id", "chain_id", "tx_type", "business_type", "token_id", "amount", "reason_type"}
	transactionColumnsWithDefault    = []string{"id", "operation_id", "related_user_id", "transfer_direction", "amount_usd", "status", "tx_hash", "block_number", "batch_id", "is_batch_operation", "gas_saved_percentage", "reason_detail", "metadata", "created_at", "confirmed_at", "failure_reason", "updated_at"}
	transactionPrimaryKeyColumns     = []string{"id"}
	transactionGeneratedColumns      = []string{}
)

type (
	// TransactionSlice is an alias for a slice of pointers to Transaction.
	// This should almost always be used instead of []Transaction.
	TransactionSlice []*Transaction

	transactionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	transactionType                 = reflect.TypeOf(&Transaction{})
	transactionMapping              = queries.MakeStructMapping(transactionType)
	transactionPrimaryKeyMapping, _ = queries.BindMapping(transactionType, transactionMapping, transactionPrimaryKeyColumns)
	transactionInsertCacheMut       sync.RWMutex
	transactionInsertCache          = make(map[string]insertCache)
	transactionUpdateCacheMut       sync.RWMutex
	transactionUpdateCache          = make(map[string]updateCache)
	transactionUpsertCacheMut       sync.RWMutex
	transactionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single transaction record from the query.
func (q transactionQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Transaction, error) {
	o := &Transaction{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for transactions")
	}

	return o, nil
}

// All returns all Transaction records from the query.
func (q transactionQuery) All(ctx context.Context, exec boil.ContextExecutor) (TransactionSlice, error) {
	var o []*Transaction

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Transaction slice")
	}

	return o, nil
}

// Count returns the count of all Transaction records in the query.
func (q transactionQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count transactions rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q transactionQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if transactions exists")
	}

	return count > 0, nil
}

// Chain pointed to by the foreign key.
func (o *Transaction) Chain(mods ...qm.QueryMod) chainQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"chain_id\" = ?", o.ChainID),
	}

	queryMods = append(queryMods, mods...)

	return Chains(queryMods...)
}

// Token pointed to by the foreign key.
func (o *Transaction) Token(mods ...qm.QueryMod) supportedTokenQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TokenID),
	}

	queryMods = append(queryMods, mods...)

	return SupportedTokens(queryMods...)
}

// LoadChain allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadChain(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		var ok bool
		object, ok = maybeTransaction.(*Transaction)
		if !ok {
			object = new(Transaction)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeTransaction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeTransaction))
			}
		}
	} else {
		s, ok := maybeTransaction.(*[]*Transaction)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeTransaction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeTransaction))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		args[object.ChainID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			args[obj.ChainID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`chains`),
		qm.WhereIn(`chains.chain_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Chain")
	}

	var resultSlice []*Chain
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Chain")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for chains")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for chains")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Chain = foreign
		if foreign.R == nil {
			foreign.R = &chainR{}
		}
		foreign.R.Transactions = append(foreign.R.Transactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ChainID == foreign.ChainID {
				local.R.Chain = foreign
				if foreign.R == nil {
					foreign.R = &chainR{}
				}
				foreign.R.Transactions = append(foreign.R.Transactions, local)
				break
			}
		}
	}

	return nil
}

// LoadToken allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadToken(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		var ok bool
		object, ok = maybeTransaction.(*Transaction)
		if !ok {
			object = new(Transaction)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeTransaction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeTransaction))
			}
		}
	} else {
		s, ok := maybeTransaction.(*[]*Transaction)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeTransaction)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeTransaction))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		args[object.TokenID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			args[obj.TokenID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`supported_tokens`),
		qm.WhereIn(`supported_tokens.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SupportedToken")
	}

	var resultSlice []*SupportedToken
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SupportedToken")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for supported_tokens")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for supported_tokens")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Token = foreign
		if foreign.R == nil {
			foreign.R = &supportedTokenR{}
		}
		foreign.R.TokenTransactions = append(foreign.R.TokenTransactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.TokenID == foreign.ID {
				local.R.Token = foreign
				if foreign.R == nil {
					foreign.R = &supportedTokenR{}
				}
				foreign.R.TokenTransactions = append(foreign.R.TokenTransactions, local)
				break
			}
		}
	}

	return nil
}

// SetChain of the transaction to the related item.
// Sets o.R.Chain to related.
// Adds o to related.R.Transactions.
func (o *Transaction) SetChain(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Chain) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"chain_id"}),
		strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.ChainID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ChainID = related.ChainID
	if o.R == nil {
		o.R = &transactionR{
			Chain: related,
		}
	} else {
		o.R.Chain = related
	}

	if related.R == nil {
		related.R = &chainR{
			Transactions: TransactionSlice{o},
		}
	} else {
		related.R.Transactions = append(related.R.Transactions, o)
	}

	return nil
}

// SetToken of the transaction to the related item.
// Sets o.R.Token to related.
// Adds o to related.R.TokenTransactions.
func (o *Transaction) SetToken(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SupportedToken) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"token_id"}),
		strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.TokenID = related.ID
	if o.R == nil {
		o.R = &transactionR{
			Token: related,
		}
	} else {
		o.R.Token = related
	}

	if related.R == nil {
		related.R = &supportedTokenR{
			TokenTransactions: TransactionSlice{o},
		}
	} else {
		related.R.TokenTransactions = append(related.R.TokenTransactions, o)
	}

	return nil
}

// Transactions retrieves all the records using an executor.
func Transactions(mods ...qm.QueryMod) transactionQuery {
	mods = append(mods, qm.From("\"transactions\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"transactions\".*"})
	}

	return transactionQuery{q}
}

// FindTransaction retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindTransaction(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Transaction, error) {
	transactionObj := &Transaction{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"transactions\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, transactionObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from transactions")
	}

	return transactionObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Transaction) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no transactions provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(transactionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	transactionInsertCacheMut.RLock()
	cache, cached := transactionInsertCache[key]
	transactionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			transactionAllColumns,
			transactionColumnsWithDefault,
			transactionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(transactionType, transactionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(transactionType, transactionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"transactions\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"transactions\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into transactions")
	}

	if !cached {
		transactionInsertCacheMut.Lock()
		transactionInsertCache[key] = cache
		transactionInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Transaction.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Transaction) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	key := makeCacheKey(columns, nil)
	transactionUpdateCacheMut.RLock()
	cache, cached := transactionUpdateCache[key]
	transactionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			transactionAllColumns,
			transactionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update transactions, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"transactions\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, transactionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(transactionType, transactionMapping, append(wl, transactionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update transactions row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for transactions")
	}

	if !cached {
		transactionUpdateCacheMut.Lock()
		transactionUpdateCache[key] = cache
		transactionUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q transactionQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for transactions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for transactions")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o TransactionSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), transactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, transactionPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in transaction slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all transaction")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Transaction) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no transactions provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	nzDefaults := queries.NonZeroDefaultSet(transactionColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	transactionUpsertCacheMut.RLock()
	cache, cached := transactionUpsertCache[key]
	transactionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			transactionAllColumns,
			transactionColumnsWithDefault,
			transactionColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			transactionAllColumns,
			transactionPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert transactions, could not build update column list")
		}

		ret := strmangle.SetComplement(transactionAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(transactionPrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert transactions, could not build conflict column list")
			}

			conflict = make([]string, len(transactionPrimaryKeyColumns))
			copy(conflict, transactionPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"transactions\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(transactionType, transactionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(transactionType, transactionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert transactions")
	}

	if !cached {
		transactionUpsertCacheMut.Lock()
		transactionUpsertCache[key] = cache
		transactionUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Transaction record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Transaction) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Transaction provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), transactionPrimaryKeyMapping)
	sql := "DELETE FROM \"transactions\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from transactions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for transactions")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q transactionQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no transactionQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from transactions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for transactions")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o TransactionSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), transactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"transactions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, transactionPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from transaction slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for transactions")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Transaction) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindTransaction(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TransactionSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := TransactionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), transactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"transactions\".* FROM \"transactions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, transactionPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in TransactionSlice")
	}

	*o = slice

	return nil
}

// TransactionExists checks if the Transaction row exists.
func TransactionExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"transactions\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if transactions exists")
	}

	return exists, nil
}

// Exists checks if the Transaction row exists.
func (o *Transaction) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return TransactionExists(ctx, exec, o.ID)
}
